# Цифровая акустическая система оценки состояния лёгких
Александр Родионов, МКН
Руководитель Я.А. Туровский

--------------------------------------------------------------------------------

# Цели работы
целью моей работы являлись
- устройство для оценки состояния легких
- написание ПО для этого устройства
- разработка комп модели легких

Предполагается, что:
с помощью данного устройства можно производить обследования пациента следующего рода:
- к пациенту прикладывается стетоскоп в области легких
- далее
    - либо к другой части туловища
    - либо к гортани
    - либо в ротовую полость
прикладывается динамик, издающий звуковые импульсы на разных частотах

Звук проходит через легкие и регистрируется микрофоном в стетоскопе и передается на компьютер. 
На компьютере звук исследуется различными спектральными методами. 
В зависимости от состояния легких пациента, звук может подвергаться различным искажениям во время прохождения, спектр звука может меняться. 
С помощью данного устройства предполагается исследование состояния легких и выявление отклонений от нормы.
    
--------------------------------------------------------------------------------

# Устройство
- микроконтроллер Arduino Due
- Микрофон + Усилитель
- Динамики
- трубка с 2 датчиками давления для 

Это все соединяется в одном корпусе. Устройство собирает данные с датчиков и передает их на компьютер.

Трубка с датчиками давления и с перегородкой внутри позволяют автоматически определять моменты вдоха и выдоха и производить запись этих моментов.
Это удобно потому что именно моменты вдохов и выдохов интересны для анализа.

Трубка была изготовлена с помощью технологии 3D печати

--------------------------------------------------------------------------------

# Програмное обеспечение для устройства
## по для Arduino
bla - bla - bla
## по для компьютера
- desktop-приложение
- написана на языке python с использованием графического фреймворка `PyQt` (дает кроссплатформеннсть)
- native os threads in python. IPC: signals slots qt. Для общения между потоками графическово интерфейса и ридером с устройства по usb.
- python - потому что много удобных библиотек для обработки сигналов, графиков итд
- header, wait_header, packets, deque

### повышение качества спектрограмм
обычное Оконное преобразование Фурье / STFT / Short-time Fourier transform
имеет известный недостаток. Качество спектрограмм в низких частотах достаточно плохое даже при высокой `fs` шаг достаточно получается достаточно большим. Особенно если учитывать что спектрограммы обычно изображаются в логарифмической шкале по оси частот, потому что мы нелинейно воспринимаем высоту звука.

Есть `wavelet transform`, есть `constant q transform`. 
В данной работе для улучшения качества спектрограм был использован более простой способ. Я буду использовать набор кросс корелляций вместо обычного FFT. Нас сейчас не интересует разложение сигнала в другой базис и возможность обратной трансформации. Нам нужно нагенерировать признаки - сколько в нашем сигнале синусоид разной частоты. Эти похоже на подход который используется в CNN сетях.

Коротко напомню что такое кросс-корреляция и каких она бывает типов.
- full
- valid
- same


тут значек звездочка, я так обозначил кросс-корелляцию. 
Просто обычно так обозначают свертку, их часто путают, похожие понятия - 
в свертке либо 1 либо 2 вектор переворачивается слева направо.
тоже самое. Даже в CNN - сверточные нейронные сети - но на самом деле там свертка почти никогда не используется, почти всегда там используют именно кросс корелляцию. Потому что как бы а зачем добавлять излишнюю сложность - переворачивать картинку или сложность, сеть просто адаптируется либо к обычным фильтрам / изображениям либо к перевернутым и перестроит веса. Результат будет одинаковый.


Эти синусоиды это как набор фильтров в CNN сетях.

В результате корелляции 2х векторов появляется новый вектор.


- `mode='full'` там где есть хотя бы одно пересечение
- `mode='same'` Only return the middle values of the convolution. Берем только середину от full длиной равной длиной большего из 1 и 2 векторов. У нас b больше, его длина 5 соответсвенно мы берем середину от full длиной 5, выходной вектор длины 5.
- `mode='valid'` только там где полное пересечение тоесть

Оказывается если длины векторов равны то valid cross corellation это просто dot product. , скалярное произведение. Тоесть просто перемножить и сложить

Мы использовали именно такой вариант.

Если преобразовать формулу DFT к такому виду то здесь очевидны 2 корелляции - с косинусоидами и с синусоидам. Первая дает Re значения X[k], вторая Im X[k] , X[k] - комплексное число.


немного преобразуем формулу для преобразования фурье. 
Мы видим что в DFT производится корелляция лишь с N частотами. Нам этого мало, мы хотим четкие спектрограммы, 

Короче предложено - использовать набор синусоид и косинусоид произвольных  частот / сколько необходимо.

Ну а более детально наш сигнал не целиком кореллируется а он разбивается на куски с нахлестом/перекрытием

транспонируем
теперь произведение этих двух матриц даст нам нужную нам спектрограмму высокого качества

Напоминаю что это только действительная часть спектрограммы. Также нужно посчитать мнимую кореллирую с синусоидами. Потом взять модуль и логарифм от получившейся комплексной матрицы. Тогда это будет спектрограмма.

Как и для любого оконного фурье нужно домножить на какое то окно например окно Hann, Hamming, Blackman чтобы избежать артефактов.

----

Расчет спектрограммы это просто перемножение двух матриц, эта операция хорошо выполняется на GPU. Для этого я использовал библиотеку cupy. Вот бенчмарк
cupy + benchmark plot from my twitter

также для ускорения разбиения аудиозаписи на куски с перекрытиями / скользящее окно для DFT использовался низкоуровневый функционал библиотеки numpy.

В Numpy Массивы, даже многомерные хранятся единым последовательным куском в памяти. Существует много способов представить многомерный массив в одном блоке памяти. В Numpy имплементирован 

Every array has a number of `dimensions`, a `shape`, a `data type`, and `strides`. Strides describe how the items of a multidimensional array are organized in the data buffer.

NumPy implements a strided indexing scheme, where the position of any element is a linear combination of the dimensions, the coefficients being the strides. In other words, strides describe, in any dimension, how many bytes we need to jump over in the data buffer to go from one item to the next.

Artificially changing the strides allows us to make some array operations more efficient than with standard methods, which may involve array copies.

The as_strided() method takes an array, a shape, and strides as arguments. It creates a new array, but uses the same data buffer as the original array. The only thing that changes is the metadata. This trick lets us manipulate NumPy arrays as usual, except that they may take much less memory than what NumPy thinks. 

Strides are the number of bytes you need to step in each dimension when traversing the array.

Так вот можно создать новый массив который будет использовать данные старого но будет юзать метадату - новые страйды.
Короче 

---

немножко исправить положение помогает трюк: можно брать большой nperseg, тогда шаги будут меньше. А чтобы исправить положение по горизонтали - можно просто делать большой noverlap. Но этот трюк все равно не очень помогает.

nyquist limit

---

зачем улучшать качество спектрограммы - потом планируется подавать в CNN, пока не подали потому что мало данных. Мы пробывали ходить по больницам - что то записали, но этого мало. Будем также использовать открытые датасеты источники записей.

ссылка на презентацию будет в конце - можно будет перейти отсюда по ссылке.

--------------------------------------------------------------------------------
## Lungs model
также была создана компьютерная модель распространения звука в легких. За основу модели была взята предложенная вот в этой статье.

... все по слайдам

для этой модели для быстрого расчета следующего состояния была использована либа numba. Это по сути jit компилятор. Он на ходу компилирует питоновский код, которые как известно медленный. с помощью LLVM в высоко оптимизированный машинный код с учетом поддержки современных векторизированных инструкций. Пишешь несколько аннотаций к своей функции и она ускоряется в разы.


--------------------------------------------------------------------------------
