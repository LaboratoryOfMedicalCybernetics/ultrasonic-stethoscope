Микроконтроллер Arduino Due делает следующие операции:
- собирает данные с микрофона
- издает звуковые импульсы через динамик
- собирает данные с двух датчиков давления bmp280
- передает эти данные через usb на компьютер

## сбор данных с микрофона
Микрофон подсоединяется к пину `A0` микроконтроллера. Напряжение с этого пина считывается и передается в АЦП/ADC преобразуясь в числа. Далее микроконтроллер считывает данные с АЦП и передает их через USB на компютер.


В начале программы инициализируется буффер в который будет производится запись полученных данных с АЦП:

```cpp
volatile int bufn, obufn;
uint16_t buf[4][256];   // 4 buffers of 256 readings
```

АЦП инициализируется следующим кодом:
bro
```cpp
void init_adc() {
    pmc_enable_periph_clk(ID_ADC);
    adc_init(ADC, SystemCoreClock, ADC_FREQ_MAX, ADC_STARTUP_FAST);
    ADC -> ADC_MR |= 0x80; // free running

    ADC -> ADC_CHER = 0x80;

    NVIC_EnableIRQ(ADC_IRQn);
    ADC -> ADC_IDR = ~(1 << 27);
    ADC -> ADC_IER = 1 << 27;
    ADC -> ADC_RPR = (uint32_t)buf[0]; // DMA buffer
    ADC -> ADC_RCR = 256;
    ADC -> ADC_RNPR = (uint32_t)buf[1]; // next DMA buffer
    ADC -> ADC_RNCR = 256;
    bufn = obufn = 1;
    ADC -> ADC_PTCR = 1;
    ADC -> ADC_CR = 2;
}
```

Здесь стоит отметить включение режима прямого доступа к памяти (DMA: Direct Memory Access). АЦП записывает данные в буфферы DMA. Отуда они идут в переменную `buf`. Переменная `buf` это двухмерный массив размером (4, 256): запись производится циклически в эти 4 массива.
Функция которая периодически сдвигает буфферы выглядит так:

```cpp
void ADC_Handler() {    // move DMA pointers to next buffer
    int f = ADC -> ADC_ISR;
    if (f & (1 << 27)) {
        bufn = (bufn + 1) & 3;
        ADC -> ADC_RNPR = (uint32_t)buf[bufn];
        ADC -> ADC_RNCR = 256;
    }
}
```

Эта функция вызывается в стандартной для Arduino функции `setup()`:

```cpp
void setup() {
    
    // ...
    
    init_adc();
}
```

В стандартной для Arduino функции `loop()` происходит ожидание пока буфер заполнится. Буффер содержит значения типа данных `uint16_t`. Чтобы передать данные через USB при помощи функции `SerialUSB.write` данные преобразуются в байты.
Также производится увеличение переменной `obufn`, означающее что нужно записывать в следующий буффер.

```cpp
while (obufn == bufn); // wait for buffer to be full
uint8_t* buffer_bytes = (uint8_t *) buf[obufn];
obufn = (obufn + 1) & 3; // 0 1 2 3 0 1 2 3 0 1 2 3 ..., like % 3
```

## генерация звука
К микроконтроллеру подсоединяются динамики через аудиовыход. Сами динамики питаются от USB. Аудиовыход подключается к ЦАП `DAC1`.

В начале программы устанавливаются следующие переменные и константы:

```cpp
// установка пина к которому подключены динамики
#define BEEP_PIN DAC1

// частота издаваемых импульсов в герцах
float freq = 1498; // Hz

// длина звукового импульса в микросекундах
const uint32_t tone_duration          =   1000000/16;

// длина паузы (тишины) между импульсами в микросекундах
const uint32_t short_silence_duration =   1000000/16;

// переменные для хранения текущих времени старта импульса и времени старта паузы
uint32_t short_silence_start_t = 0;
uint32_t tone_start_t          = 0;

// переменная-флаг: звучит импульс или нет
uint8_t is_tone_playing = 1;

// амплитуда звукового сигнала
const float A = 490;                           // amplitude of sine signal

const float pi = 3.14159265;

// время семплирования (1/частота дискретизации)
float _T = 50 / 1000000.0;                     // set default sampling time in microseconds

// массив для звуковой волны которая будет записываться в ЦАП
// т.к. эта переменная будет обновляться через прерывания то она должна быть volatile
volatile float a[3];                           // filter register for generating tone

// угловая частота
float omega = 2.0 * pi * freq;                 // angular frequency in radians/second

// константы, необходимые для генерации синусоиды
float wTsq = _T * _T * omega * omega;          // omega * sampling frequency squared
float c1  = (8.0 - 2.0 * wTsq) / (4.0 + wTsq); // c1 = first filter coefficient
```

В функции `setup.py` строчки отвечающие за генерацию звука делают следующее:

```cpp
// Устанавливается разрешение ЦАП
analogWriteResolution(10);

// устанавливаем пин ЦАП в режим выхода
pinMode(BEEP_PIN, OUTPUT);

// устанавливаем пин светодиода в режим выхода 
// светодиод будет загораться одновременно со звуковыми импульсами
pinMode(LED_BUILTIN, OUTPUT);

// функции beep_handler отвечающей за генерацию импульсов
// назначается вызов по прерыванию (каждые 50 микросекунд)
Timer1.attachInterrupt(beep_handler).start(50);
```

В функции `beep_handler` происходит следующее.

Если переменная `is_tone_playing` равна 1 то:

проверяется сколько прошло времени с момента запуска импульса. Если прошло меньше чем длительность импульса то продолжается генерация звуковой волны и запись ее в ЦАП. Также светодиод продолжает гореть. Если время превысило длительность импульса то `is_tone_playing` становится равна нулю. Также обнуляется фаза звуковой волны. Также фиксируется время начала паузы.

Если переменная `is_tone_playing` равна 0 то:

проверяется не прошло ли время паузы. Если нет то записываем 0 в ЦАП. И светодиод находится в выключенном положении. Если прошло то меняем `is_tone_playing` на 1 и фиксируем время старта звукового импульса.


```cpp
void beep_handler() {
    if (is_tone_playing) {
        if (micros() - tone_start_t < tone_duration) {
            // play tone samples (src: https://github.com/cmasenas/SineWaveDue)
            digitalWrite(LED_BUILTIN, HIGH);
            a[2] = c1 * a[1] - a[0];       // compute the sample
            a[0] =      a[1]       ;       // shift the registers in preparation for the next cycle
            a[1] =      a[2]       ;
            analogWrite(BEEP_PIN, a[2] + 500); // write to DAC
        }
        else {
            is_tone_playing = 0;

            // reset sine phase (without reset, phases of sine-tones are constantly shifting)
            a[0] = 0.0;
            a[1] = A * sin(omega * _T);
            a[2] = 0.0;

            short_silence_start_t = micros();
        }
    }
    else {
        if (micros() - short_silence_start_t < short_silence_duration) {
            digitalWrite(LED_BUILTIN, LOW);
            analogWrite(BEEP_PIN, 0);
        }
        else {
            is_tone_playing = 1;
            tone_start_t = micros();
        }
    }
}
```

Код, отвечающий за генерацию звуковой волны взят из исходного кода библиотеки SineWaveDue (https://github.com/cmasenas/SineWaveDue) (из метода `SineWaveDue::playTone`)
