## `serial_port` - сбор сигнала от устройства через usb

Подключение к ардуино по usb происходит с использованием файла `arduino.py`. Этот файл используется для многих проектов поэтому он лежит за пределами папки данного проекта. 
В python чтобы импортировать модуль, который лежит по произвольному пути, этот путь нужно добавтить в `sys.path`:

```py
import sys; sys.path.append('/Users/tandav/Documents/spaces/arduino'); import arduino
port = arduino.find_device()
```

Функция `find_device` пытается 60 раз просканировать доступные usb-устройства c помощью функции `serial.tools.list_ports.comports()` если в описании какого либо из устройств содержаться следующие ключевые слова: 

```py
device_keywords = (
    'Arduino',
    'USB Serial Device',
    'Устройство с последовательным интерфейсом USB',
)
```
то устройство опознается как Arduino и возвращается. 

Если через 60 попыток Arduino не найдено, то выбрасывается исключение: `serial.SerialException('device not found, check the connection')`

----------------------------------------------------------------

Далее в модуле `serial_port` происходит объявление следующих переменных и констант:

```py
# заголовок пакета с данными от Arduino
# должен быть такой же как в коде программы для Arduino
header = b'\xd2\x02\x96I'


# длины различных частей пакета в байтах:

# длина блока данных, отвечающего за один сенсор давления
bmp_pressure_length    =   4 # float32 number

# длина блока данных, отвечающего за данные с микрофона
mic_length             = 512 # 256 uint16
mic_chunk_size         = mic_length // 2 # uint16 takes 2 bytes

# длина блока данных, отвечающего за информацию о том, издают ли звук динамики
is_tone_playing_length =   1 # uint8 (used like bool)

# сумарная длина пакета без заголовка
payload_length         =   2 * bmp_pressure_length + is_tone_playing_length + mic_length

# сумарная длина пакета с заголовком
packet_length          = len(header) + payload_length

# переменная-флаг, отвечающая за то, следует ли продолжать сбор данных
# (используется в момент закрытия приложения)
stop_flag = 0

# число пакетов которые прошли без потери данных (используется для дебага)
n_good_packets = 0
```

Далее в модуле `serial_port` объявляются функции `read_packet`, `read_packet_bytes`, `wait_header`. Они непосредственно отвечают за сбор данных через серийный порт. Функция `read_packet_bytes` читает из серийного порта количество байт равное длине пакета. Далее происходит проверка: полученные байты должны начинаться с заголовка. Если условие выполняется, то возвращаются полезные нагрузочные байты (payload) пакета (без заголовка). Если условие не выполняется то вызывается вспомогательная функция `wait_header` которая читает данные пока не дождется заголовка. После того как заголовок был считан, читается отавшаяся часть пакета и возвращается.

```py
def read_packet_bytes():
    '''
    packet_length: packet length in bytes
    returns packet (as bytes) without header
    '''

    global n_good_packets

    packet = port.read(packet_length)

    if packet.startswith(header):
        n_good_packets += 1
        if n_good_packets % 5000 == 0:
            print(f'n_good_packets = {n_good_packets}')
        return packet[len(header):]
    else:
        print(f'wrong header {packet[:len(header)]} before: n_good_packets = {n_good_packets}')
        n_good_packets = 0
        # time.sleep(1)
        wait_header()
        return port.read(payload_length) # rest of packet
```

Ожидание заголовка в функции `wait_header` реализовано с помощью использования структуры данных `deque` из модуля стандартной библиотеки питона `collections`. `deque` - двухстороння очередь. Эту структуру можно использовать и как для очередей с порядком LIFO (Stack, используется только одна сторона `deque`), так и для очереди с порядком FIFO (используется 2 стороны `deque`). В данной функции `deque` используется как очередь с порядком `FIFO` с максимальным количеством элементов равным 4 (количество байт в заголовке).

Данные читаются с серийного порта по одному байту и помещаются в очередь справа (`append`). Старые байты автоматически вытесняются с другого конца (слева). Данные читаются до тех пор, пока 4 байта, которые хранятся в очереди не будут равняться четырем байтам заголовка (с учетом порядка). Как только это условие выполняется, происходит выход из функции.

```py
def wait_header():
    deque = collections.deque(maxlen=len(header))

    while b''.join(deque) != header:
        deque.append(port.read())

    print('wait done', b''.join(deque), '==', header)
```

Функция `read_packet` использует функцию `read_packet_bytes`, чтобы получить байты пакета без заголовка. Затем происходит разделение байт на различные переменные с использованием функции библиотеки `numpy` `np.frombuffer` с кастингом байт в необходимые типы данных:

```py
def read_packet():
    packet = read_packet_bytes()
    
    # данные 1 датчика давления
    bmp0 = np.frombuffer(packet[ :4], dtype=np.float32)[0]
    
    # данные 2 датчика давления
    bmp1 = np.frombuffer(packet[4:8], dtype=np.float32)[0]
    
    # переменная, хранящая информацию о том, издают ли звук динамики
    is_tone_playing = np.frombuffer(packet[8:9], dtype=np.uint8)[0]
    
    # данные с микрофона
    mic = np.frombuffer(packet[9:521], dtype=np.uint16)

    # возможное прорежение сигнала / понижение частоты дискретизации
    # (используется на слабых компьютерах)
    # downsampling = 4
    # downsampling = 8
    downsampling = 1

    mic =  (
        mic
        .reshape(len(mic) // downsampling, downsampling)
        .mean(axis=1)
    )

    return bmp0, bmp1, is_tone_playing, mic
```

далее в модуле `serial_port` объявляется замок, который будет в дальнейшем использоваться в тех местах где потенциально 2 процесса могут обращаться к одной переменной:

```py
lock = threading.Lock()
```

Поток `serial_port` собирает данные в буффер-очередь. Этот буффер нужен является временным хранилищем прочитанных данных до тех пор, пока поток графического интерфейса не прочитает их.

### функция `run`
В основной функции `run`, которую будет исполнять тред присутсвует бесконечный цикл. 

В начале цикла проверяется не включен ли флаг `stop_flag` (который может быть включен если пользователь закроет окно (метод `closeEvent` в классе `gui`) или через прерывание с клавиатуры в коммандной строке (CTRL-C). Если флаг включен то соединение с устройством через серийный порт закрывается:

```py
while True:

    if stop_flag:
        port.close()
        return
```

Далее по циклу происходит вызов функции `read_packet`:
```py
bmp0, bmp1, is_tone_playing, mic = read_packet()
```

Графический интерфейс будет читать данные не каждый раз когда они появились а реже (слишком частое чтение тормозит графический интерфейс и делает его неотзывчивым). Более точно, поток `serial_port` посылает потоку графического интерфейса сигнал о том, что нужно получить новую порцию данных всякий раз когда:
- считалось новое значение на сенсорах давления, отличающеесе от предыдущего значения (скорость обновления давления на сенсорах значительно медленнее чем скорость обновления данных с микрофона, поэтому перерисовка происходит сразу как только данные пришли)
- так как данные микрофона обновляются очень часто, то сигнал о том что нужно обноивить графики в графическом интерфейсе посылается через каждые 128 чтений.

Эта логика реализована в оставшейся части функции `run`:

```py
if bmp0 != bmp0_prev or bmp1 != bmp1_prev:

    bmp0_prev = bmp0
    bmp1_prev = bmp1

    bmp_signal.emit()


mic_buffer.extend(mic)
mic_i += len(mic)

if mic_i == mic_un:
    mic_i = 0

    t1 = time.time()
    dt = t1 - t0
    rate = mic_un / dt
    _rate_arr[_rate_i] = rate
    _rate_i += 1
    if _rate_i == len(_rate_arr):
        rate_mean = _rate_arr.mean()
        _rate_i = 0
    t0 = t1
    mic_signal.emit()
```

Также здесь замеряется средняя частота дискретизации `rate_mean` - сколько в среднем приходило значений в секунду с микрофона.

Когда потоку графического интерфейса посылаются сигналы `bmp_signal.emit()` и `mic_signal.emit()` чтобы он запросил новые данные, то поток `gui` вызывает функции `get_bmp` и `get_mic`. В `get_bmp` просто возвращаются последние значения с сенсоров. В `get_mic` берутся последние несколько значений из `mic_buffer` и также делается преобразование фурье:

```py
# получаются последние nfft значений
mic_for_fft = mic_buffer.most_recent(nfft)  # with overlap (running window for STFT)

# формируем массив частот для графика спектра
f = np.fft.rfftfreq(nfft, d=1/rate_mean/2)

# преобразуем сигнал в коэффициенты фурье
a = np.fft.rfft(mic_for_fft)

# берем модуль комплексного числа
a = np.abs(a)  # magnitude

# преобразуем магнитуду в децибеллы
a = 10 * np.log10(a)

# ограничение возвращаемых частот спектра (интересующий нас диапазон)
hz_limit  = (f > 40) & (f < 40_000)
fft_f = f[hz_limit]
fft_a = a[hz_limit]

return mic, fft_f, fft_a, rate_mean
```
